<script src="../simpletest.js"></script>
<script>

  // The concat() method is used to merge two or more arrays.
  // This method does not change the existing arrays,
  // but instead returns a new array.

  // Return Value:
  //   A new Array instance.

  // Args:
    // valueN:
      // If valueN is undefined, concat returns a shallow copy of the existing array
      // on which it is called.

  // It should return a new array.

  // It should create a new array consisting of the elements called in order.

  // It should create a new array consisting of the elements if they are an array.

  // It should create a new array consisting of the elements if they are not an array.

  // It should return a shallow copy of the original arrays.
      // It should copy object refereces into the new array.
      // Both the new and original array should refer to the same object.

  // It should copy the values of strings and numbers into the new array.

  // It should include holes

  // It should demonstrate the retention of references

  // Concatenating array(s)/value(s) will leave the originals untouched. Furthermore, any operation
  // on the new array (except operations on elements which are object references)
  // will have no effect on the original arrays, and vice versa.

// Retention of References:
// var num1 = [[1]];
// var num2 = [2, [3]];
//
// var nums = num1.concat(num2);
//
// console.log(nums);
// results in [[1], 2, [3]]
//
// modify the first element of num1
// num1[0].push(4);
//
// console.log(nums);
// results in [[1, 4], 2, [3]]

// function concat() {
//     var concated = [];
//
//     // method takes valueN as an arg.
//     // valueN is equal to arguments.length, since it takes a seemingly unlimited value of args
//     // first we must consider adding arrays together first
//     for (var i = 0; i < arguments.length; i++) {
//       // loop through the arguements, and check if they're arrays
//       if (Array.isArray(arguments[i])) {
//         // if true, loop through the element arrays
//         for (var j = 0; j < arguments[i].length; j++) {
//         if (j in arguments[i]) {
//             concated.push(arguments[i][j]);
//           }  else {
//             concated.length++;
//           }
//         }
//       } else {
//       if (i === 0) {
//         if (Object.prototype.toString.call8arguments[i] === '[object Object]') {
//           cocnated.push(arguments[i]);
//         } else {
//           if (arguments[i] === null || arguments[i] === undefined) {
//             throw new TypeError('Do not pass in null or undefined as the first argument');
//           } else if (arguments[i] === 'number' || arguments[i] === 'string' || arguments[i] === 'boolean') {
//             concated.push(arguments[i]);
//           }
//         }
//       } else {
//         concated.push(arguments[i]);
//       }
//     }
//   }
//   return concated
// }

function concat() {
    var concated = [];

    // Loop through the arguments
    for (var i = 0; i < arguments.length; i++) {
      // Check if argument is an array
      if (Array.isArray(arguments[i])) {
        // Loop through elements of the array
        for (var j = 0; j < arguments[i].length; j++) {
          // if the elements are in the array push them to the new array
          if (j in arguments[i]) {
            concated.push(arguments[i][j]);
          } else {
            // else add length -> holes
            concated.length++;
          }
        }
      } else {
        // If no args
        if (i === 0) {

          if (Object.prototype.toString.call(arguments[i]) === "[object Object]") {
            concated.push(arguments[i]);
          } else {
            // If args being passed are null or undefined throw error
            if (arguments[i] === null || arguments[i] === undefined) {
              throw new TypeError('Do not pass in null or undefined as the 1st argument.');
              // else if data types number, string, boolean, symbol are being passed
              // turn them into objects
            } else if (typeof arguments[i] === "number" || typeof arguments[i] === "string" || typeof arguments[i] === "boolean" || typeof arguments[i] === "symbol") {
              let toObject = Object(arguments[i]);
              concated.push(toObject);
            }
          }
        } else {//i !== 0
          concated.push(arguments[i]);
        }
      }
    }
    return concated;
  }


  tests({
    'It should return an array': function() {
      var arr1 = [1];
      var arr2 = [2];
      var result = concat(arr1, arr2);
      eq(Array.isArray(result), true);
    },

    'It should return a new array': function() {
      var arr1 = [1];
      var arr2 = [2];
      var result = concat(arr1, arr2);
      eq(result !== arr1, true);
      eq(result !== arr2, true);
    },

    'It should add two or more arrays together': function() {

      var arr1 = [1,2,3];
      var arr2 = [4,5,6];
      var arr3 = [7,8,9];
      var expected = [1,2,3,4,5,6,7,8,9];
      var result = concat(arr1, arr2, arr3);
      result.forEach(function(ele, i) {
        eq(ele, expected[i])
      });
    },

    'It handles data types besides arrays by adding them to the new array.': function () {
     var result = concat([0], true, 5, 'string', {}, function () {}, null, undefined, NaN);
     eq(result.toString(), "0,true,5,string,[object Object],function () {},,,NaN");
   },

   'It should accept holes.': function () {
      var array = [,,,];
      var result = concat(array, 1);
      eq(result.length, 4);
      eq(0 in result, false);
    },

    'It should copy object references into the new array.': function () {
     var object = {name: 'zack'};
     var result = concat([1], object);
     eq(result.length, 2);
     eq(result[0], 1);
     eq(result[1].name, "zack");
     object.name = 'zack';
     eq(result[1].name, "zack");
   },

    'If pass in an object as 1st argument, add the object reference to the new array.': function () {
     var object = {1: 1};
     var expected = [object, 1];
     var result = concat(object, 1);
     result.forEach(function (ele, i) {
       eq(ele, expected[i]);
     });
   },
   'If pass in null as 1st argument, throw a TypeError.': function () {
      var isTypeError = false;
      try {
        concat(null, 1);
      } catch (e) {
        isTypeError = e instanceof TypeError;
      }
      eq(isTypeError, true);
    },
    'If pass in undefined as 1st argument, throw a TypeError.': function () {
      var isTypeError = false;
      try {
        concat(undefined, 'hi');
      } catch (e) {
        isTypeError = e instanceof TypeError;
      }
      eq(isTypeError, true);
    },


  });
</script>
